package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"csserver/internal/appserv/csmap"
	"csserver/internal/appserv/factory"
	"csserver/internal/appserv/graph"
	"csserver/internal/appserv/graph/idl"
	"csserver/internal/appserv/orgmap"
	"csserver/internal/common"
	"csserver/internal/services/project/ptypes/projectstatus"
	"csserver/internal/utils"
	"time"

	log "github.com/sirupsen/logrus"
)

// CurrentUser is the resolver for the currentUser field.
func (r *queryResolver) CurrentUser(ctx context.Context) (*idl.User, error) {
	service := factory.GetIAMAdminService(ctx)
	orgInfo, err := orgmap.GetSaaSOrg(ctx)
	if err != nil {
		return nil, err
	}

	obj, err := service.GetCurrentUser(ctx, orgInfo.Info.Org.Realm)
	if err != nil {
		return nil, err
	}

	out := csmap.AppuserAppuserToIdl(*obj)

	return &out, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id string) (*idl.User, error) {
	service := factory.GetIAMAdminService(ctx)
	orgInfo, err := orgmap.GetSaaSOrg(ctx)
	if err != nil {
		return nil, err
	}

	obj, err := service.GetUser(ctx, orgInfo.Info.Org.Realm, id)
	if err != nil {
		return nil, err
	}

	out := csmap.AppuserAppuserToIdl(*obj)

	return &out, nil
}

// FindProjects is the resolver for the findProjects field.
func (r *queryResolver) FindProjects(ctx context.Context, pageAndFilter idl.PageAndFilter) (*idl.ProjectResults, error) {
	service := factory.GetProjectService(ctx)
	paging, filters := csmap.GetPageAndFilterModel(*pageAndFilter.Paging, pageAndFilter.Filters)

	results, err := service.FindProjects(ctx, paging, filters)
	if err != nil {
		return nil, err
	}

	pg, fi := csmap.GetPageAndFilterIdl(results.Pagination, results.Filters)
	out := idl.ProjectResults{
		Paging:  &pg,
		Filters: &fi,
		Results: csmap.ConvertProjectResultToEnvelopeSlice(ctx, utils.ValToRefSlice(results.Results)),
	}

	return &out, nil
}

// GetProject is the resolver for the getProject field.
func (r *queryResolver) GetProject(ctx context.Context, id string) (*idl.ProjectEnvelope, error) {
	service := factory.GetProjectService(ctx)
	obj, err := service.GetProjectByID(ctx, id)
	if err != nil {
		return nil, err
	}

	service.GetStatusTransitionDetails(&obj.Data)

	return csmap.ConvertProjectResultToEnvelope(ctx, obj), nil
}

// CalculateProjectSchedule is the resolver for the calculateProjectSchedule field.
func (r *queryResolver) CalculateProjectSchedule(ctx context.Context, projectID string, startDate time.Time) (*idl.ProjectScheduleResult, error) {
	projService := factory.GetProjectService(ctx)
	proj, err := projService.GetProjectByID(ctx, projectID)
	if err != nil {
		return nil, err
	}

	resourceService := factory.GetResourceService(ctx)
	rm, err := resourceService.GetResourceMap(ctx, false)
	if err != nil {
		return nil, err
	}

	scheduleService := factory.GetScheduleService(ctx)
	ram, err := scheduleService.GetInitialResourceAllocationMap(rm)
	if err != nil {
		return nil, err
	}

	schedule, err := scheduleService.CalculateProjectSchedule(ctx, &proj.Data, startDate, ram)
	if err != nil {
		return nil, err
	}

	schIdl := csmap.ScheduleScheduleToIdl(schedule)
	csmap.AugmentSchedule(ctx, &schIdl)

	out := idl.ProjectScheduleResult{
		Schedule: &schIdl,
	}

	return &out, nil
}

// CheckProjectStatus is the resolver for the checkProjectStatus field.
func (r *queryResolver) CheckProjectStatus(ctx context.Context, projectID string, newStatus string) (*idl.ValidationResult, error) {
	service := factory.GetProjectService(ctx)

	result, err := service.CheckProjectStatusChange(ctx, projectID, projectstatus.ProjectState(newStatus))
	if err != nil {
		return nil, err
	}

	out := csmap.GetValidationResultIdl(result)

	return &out, nil
}

// FindProjectComments is the resolver for the findProjectComments field.
func (r *queryResolver) FindProjectComments(ctx context.Context, projectID string) (*idl.CommentResults, error) {
	service := factory.GetCommentService(ctx)

	results, err := service.FindProjectComments(ctx, projectID)
	if err != nil {
		return nil, err
	}

	pg, fi := csmap.GetPageAndFilterIdl(results.Pagination, results.Filters)
	out := idl.CommentResults{
		Paging:  &pg,
		Filters: &fi,
		Results: csmap.ConvertCommentResultToEnvelopeSlice(ctx, utils.ValToRefSlice(results.Results)),
	}

	return &out, nil
}

// GetCommentThread is the resolver for the getCommentThread field.
func (r *queryResolver) GetCommentThread(ctx context.Context, id string) (*idl.CommentEnvelope, error) {
	service := factory.GetCommentService(ctx)
	obj, err := service.GetCommentThread(ctx, id)
	if err != nil {
		return nil, err
	}

	out := csmap.ConvertCommentResultToEnvelope(ctx, obj)
	return out, nil
}

// FindActivity is the resolver for the findActivity field.
func (r *queryResolver) FindActivity(ctx context.Context, pageAndFilter idl.PageAndFilter) (*idl.ActivityResults, error) {
	service := factory.GetActivityService(ctx)

	//---TODO: make this find paged activities
	activityResults, err := service.FindAllActivitys(ctx)
	if err != nil {
		return nil, err
	}

	pg, fi := csmap.GetPageAndFilterIdl(activityResults.Pagination, activityResults.Filters)
	out := idl.ActivityResults{
		Paging:  &pg,
		Filters: &fi,
		Results: csmap.ActivityActivityToIdlSlice(common.ValToRefSlice(common.ExtractDataFromBase(activityResults.Results))),
	}

	csmap.AugmentActivitySlice(ctx, out.Results)

	return &out, nil
}

// FindAllProjectTemplates is the resolver for the findAllProjectTemplates field.
func (r *queryResolver) FindAllProjectTemplates(ctx context.Context) (*idl.ProjecttemplateResults, error) {
	service := factory.GetProjectTemplateService(ctx)
	results, err := service.FindAllProjecttemplates(ctx)
	if err != nil {
		return nil, err
	}

	pg, fi := csmap.GetPageAndFilterIdl(results.Pagination, results.Filters)
	out := idl.ProjecttemplateResults{
		Paging:  &pg,
		Filters: &fi,
		Results: csmap.ProjecttemplateProjecttemplateToIdlSlice(common.ValToRefSlice(common.ExtractDataFromBase(results.Results))),
	}

	return &out, nil
}

// GetOrganization is the resolver for the getOrganization field.
func (r *queryResolver) GetOrganization(ctx context.Context) (*idl.Organization, error) {
	service := factory.GetOrganizationService(ctx)
	org, err := service.GetDefaultOrganization(ctx)
	if err != nil {
		return nil, err
	}

	out := csmap.OrganizationOrganizationToIdl(*org)
	csmap.AugmentOrganization(ctx, &out)
	return &out, nil
}

// GetPortfolio is the resolver for the getPortfolio field.
func (r *queryResolver) GetPortfolio(ctx context.Context) (*idl.Portfolio, error) {
	return r.GetDraftPortfolio(ctx, "")
}

// GetDraftPortfolio is the resolver for the getDraftPortfolio field.
func (r *queryResolver) GetDraftPortfolio(ctx context.Context, additionalID string) (*idl.Portfolio, error) {
	portfolioService := factory.GetPortfolioService(ctx)

	port, err := portfolioService.GetBalancedPortfolio(ctx, additionalID)
	if err != nil {
		return nil, err
	}

	start, end := port.GetDateRange()

	out := idl.Portfolio{
		Begin:    start,
		End:      end,
		Schedule: csmap.ScheduleScheduleToIdlSlice(common.ValToRefSlice(port.Schedule)),
	}

	for i := range out.Schedule {
		csmap.AugmentSchedule(ctx, out.Schedule[i])
	}

	csmap.AugmentPortfolio(ctx, &out, nil)

	return &out, nil
}

// GetPortfolioForResource is the resolver for the getPortfolioForResource field.
func (r *queryResolver) GetPortfolioForResource(ctx context.Context, resourceID string) (*idl.Portfolio, error) {
	portfolioService := factory.GetPortfolioService(ctx)

	port, err := portfolioService.GetBalancedPortfolio(ctx, "")
	if err != nil {
		return nil, err
	}

	outPort, err := portfolioService.GetPortfolioForResource(ctx, port, resourceID)
	if err != nil {
		return nil, err
	}

	start, end := port.GetDateRange()

	out := idl.Portfolio{
		Begin:    start,
		End:      end,
		Schedule: csmap.ScheduleScheduleToIdlSlice(common.ValToRefSlice(outPort.Schedule)),
	}

	for i := range out.Schedule {
		csmap.AugmentSchedule(ctx, out.Schedule[i])
	}

	csmap.AugmentPortfolio(ctx, &out, &resourceID)

	return &out, nil
}

// GetResource is the resolver for the getResource field.
func (r *queryResolver) GetResource(ctx context.Context, id string) (*idl.ResourceEnvelope, error) {
	service := factory.GetResourceService(ctx)
	obj, err := service.GetResourceByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return csmap.ConvertResourceResultToEnvelope(ctx, obj), nil
}

// FindAllUsers is the resolver for the findAllUsers field.
func (r *queryResolver) FindAllUsers(ctx context.Context) (*idl.UserResults, error) {
	service := factory.GetIAMAdminService(ctx)
	orgInfo, err := orgmap.GetSaaSOrg(ctx)
	if err != nil {
		return nil, err
	}

	userResults, err := service.FindAllUsers(ctx, orgInfo.Info.Org.Realm)
	if err != nil {
		return nil, err
	}

	log.Warn(userResults)

	pg, fi := csmap.GetPageAndFilterIdl(userResults.Pagination, userResults.Filters)
	out := idl.UserResults{
		Paging:  &pg,
		Filters: &fi,
		Results: csmap.AppuserAppuserToIdlSlice(common.ValToRefSlice(userResults.Results)),
	}

	return &out, nil
}

// FindAllResources is the resolver for the findAllResources field.
func (r *queryResolver) FindAllResources(ctx context.Context) (*idl.ResourceResults, error) {
	service := factory.GetResourceService(ctx)
	results, err := service.FindAllResources(ctx)
	if err != nil {
		return nil, err
	}

	pg, fi := csmap.GetPageAndFilterIdl(results.Pagination, results.Filters)
	out := idl.ResourceResults{
		Paging:  &pg,
		Filters: &fi,
		Results: csmap.ConvertResourceResultToEnvelopeSlice(ctx, utils.ValToRefSlice(results.Results)),
	}

	return &out, nil
}

// FindAllRoles is the resolver for the findAllRoles field.
func (r *queryResolver) FindAllRoles(ctx context.Context) (*idl.RoleResults, error) {
	service := factory.GetResourceService(ctx)
	results, err := service.FindAllRoles(ctx)
	if err != nil {
		return nil, err
	}

	pg, fi := csmap.GetPageAndFilterIdl(results.Pagination, results.Filters)
	out := idl.RoleResults{
		Paging:  &pg,
		Filters: &fi,
		Results: csmap.ConvertRoleResultToEnvelopeSlice(ctx, utils.ValToRefSlice(results.Results)),
	}

	return &out, nil
}

// FindResources is the resolver for the findResources field.
func (r *queryResolver) FindResources(ctx context.Context, pageAndFilter *idl.PageAndFilter) (*idl.ResourceResults, error) {
	service := factory.GetResourceService(ctx)
	paging, filters := csmap.GetPageAndFilterModel(*pageAndFilter.Paging, pageAndFilter.Filters)
	results, err := service.FindResources(ctx, paging, filters)
	if err != nil {
		return nil, err
	}

	pg, fi := csmap.GetPageAndFilterIdl(results.Pagination, results.Filters)
	out := idl.ResourceResults{
		Paging:  &pg,
		Filters: &fi,
		Results: csmap.ConvertResourceResultToEnvelopeSlice(ctx, utils.ValToRefSlice(results.Results)),
	}

	return &out, nil
}

// FindUserNotifications is the resolver for the findUserNotifications field.
func (r *queryResolver) FindUserNotifications(ctx context.Context, pageAndFilter *idl.PageAndFilter) (*idl.NotificationResults, error) {
	log.Error("FindUserNotifications needs refactor")

	return &idl.NotificationResults{
		Paging:  &idl.Pagination{},
		Results: []*idl.Notification{},
	}, nil

	// service := factory.GetNotificationService()
	// paging, _ := csmap.GetPageAndFilterModel(*pageAndFilter.Paging, pageAndFilter.Filters)
	// results, err := service.FindUserNotifications(ctx, paging)
	// if err != nil {
	// 	return nil, err
	// }

	// pg, fi := csmap.GetPageAndFilterIdl(results.Pagination, results.Filters)
	// out := idl.NotificationResults{
	// 	Paging:  &pg,
	// 	Filters: &fi,
	// 	Results: csmap.NotificationNotificationToIdlSlice(common.ValToRefSlice(results.Results)),
	// }

	// return &out, nil
}

// FindAllLists is the resolver for the findAllLists field.
func (r *queryResolver) FindAllLists(ctx context.Context) (*idl.ListResults, error) {
	service := factory.GetListService(ctx)
	listResults, err := service.FindAllLists(ctx)
	if err != nil {
		return nil, err
	}

	pg, fi := csmap.GetPageAndFilterIdl(listResults.Pagination, listResults.Filters)
	out := idl.ListResults{
		Paging:  &pg,
		Filters: &fi,
		Results: csmap.ListListToIdlSlice(common.ValToRefSlice(common.ExtractDataFromBase(listResults.Results))),
	}

	return &out, nil
}

// GetList is the resolver for the getList field.
func (r *queryResolver) GetList(ctx context.Context, nameOrID string) (*idl.List, error) {
	service := factory.GetListService(ctx)
	wrappedO, err := service.GetList(ctx, nameOrID)
	if err != nil {
		return nil, err
	}

	obj := *wrappedO

	out := csmap.ListListToIdl(obj.Data)

	return &out, nil
}

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
